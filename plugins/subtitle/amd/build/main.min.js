define(['jquery', 'mod_interactivevideo/type/base', 'core/event_dispatcher'], function ($, BaseModule, EventDispatcher) {

    // Handle ES6 module interoperability for Base class
    const Base = (BaseModule && BaseModule.__esModule) ? BaseModule.default : BaseModule;

    /**
     * Main class for the Subtitle plugin
     *
     * @module     ivplugin_subtitle/main
     * @copyright  2024 Antigravity
     * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
     */
    class Subtitle extends Base {

        /**
         * Initialize the subtitle functionality.
         */
        async init() {
            // Find the subtitle annotation(s)
            const subtitleAnnotations = this.annotations.filter(x => x.type === 'subtitle');
            if (!subtitleAnnotations.length) {
                return;
            }

            // We assume there's one active subtitle track we care about, or we handle the first one.
            const annotation = subtitleAnnotations[0];

            // 1. Fetch the content to get the File URL
            let htmlContent = '';
            try {
                htmlContent = await this.render(annotation);
            } catch (e) {
                console.error("IV Subtitle: Failed to render content:", e);
                return;
            }

            const $content = $(htmlContent);
            const $container = $content.is('.ivplugin-subtitle-container') ? $content : $content.find('.ivplugin-subtitle-container');

            const fileUrl = $container.attr('data-subtitle-url');
            const showSubtitle = $container.attr('data-show-subtitle') === '1';

            console.log("IV Subtitle: Init", { fileUrl, showSubtitle });

            if (!fileUrl) {
                console.warn("IV Subtitle: No file URL found.");
                if (showSubtitle) this.updateUI("No subtitle file.");
                return;
            }

            // 2. Fetch and Parse the VTT/SRT file
            try {
                const response = await fetch(fileUrl);
                if (!response.ok) throw new Error("Fetch failed: " + response.status);
                const text = await response.text();

                // Parse
                this.cues = this.parseVTT(text);
                console.log("IV Subtitle: Parsed cues", this.cues.length);

                if (this.cues.length === 0) {
                    if (showSubtitle) this.updateUI("No cues found in subtitle file.");
                } else if (showSubtitle) {
                    this.updateUI("Subtitles loaded.");
                    setTimeout(() => this.updateUI(""), 2000); // Clear loaded message
                }

                // Expose globally
                window.IV = window.IV || {};
                window.IV.subtitle = {
                    current: null,
                    all: this.cues,
                    getTranscript: (timestamp) => this.getTranscript(timestamp),
                    getFullTranscript: () => text
                };

                // Dispatch event saying subtitles are ready
                EventDispatcher.dispatchEvent('iv:subtitle:ready', { cues: this.cues });

            } catch (e) {
                console.error("IV Subtitle: Error loading file:", e);
                if (showSubtitle) this.updateUI("Error loading subtitles.");
                return;
            }

            // 3. Setup UI if needed
            if (showSubtitle) {
                this.ensureOutputContainer();
            }

            // 4. Start Time Loop
            const updateSubtitle = async () => {
                const time = await this.player.getCurrentTime();
                const activeCue = this.cues.find(cue => time >= cue.start && time <= cue.end);

                const currentText = activeCue ? activeCue.text : '';

                // Update global state
                if (window.IV.subtitle && window.IV.subtitle.current !== currentText) {
                    window.IV.subtitle.current = currentText;
                    EventDispatcher.dispatchEvent('iv:subtitle:change', { text: currentText, time: time });

                    if (showSubtitle) {
                        this.updateUI(currentText);
                    }
                }
            };

            setInterval(updateSubtitle, 250);
        }

        ensureOutputContainer() {
            if ($('#iv-subtitle-display').length === 0) {
                // Use a high z-index and ensure pointer-events:none allows clicking through to video
                $('#video-wrapper').append(
                    '<div id="iv-subtitle-display" class="text-center p-2" style="position: absolute; bottom: 10%; width: 100%; pointer-events: none; z-index: 1000; text-shadow: 1px 1px 2px black;"></div>'
                );
            }
            return $('#iv-subtitle-display');
        }

        updateUI(text) {
            const $container = this.ensureOutputContainer();
            if (text) {
                $container.html(`<span class="d-inline-block bg-dark text-white opacity-75 px-3 py-1 rounded" style="font-size: 1.1em; background-color: rgba(0,0,0,0.6) !important;">${text}</span>`);
                $container.show();
            } else {
                $container.hide();
            }
        }

        /**
         * Simple VTT/SRT parser
         */
        parseVTT(vttText) {
            const lines = vttText.trim().split(/\r?\n/);
            const cues = [];
            let currentCue = null;

            const timeToSeconds = (timeStr) => {
                // Replace comma with dot for SRT format (00:00:05,000 -> 00:00:05.000)
                timeStr = timeStr.replace(',', '.');
                const parts = timeStr.split(':');
                let hours = 0, minutes = 0, seconds = 0;

                if (parts.length === 3) {
                    hours = parseInt(parts[0], 10);
                    minutes = parseInt(parts[1], 10);
                    seconds = parseFloat(parts[2]);
                } else if (parts.length === 2) {
                    minutes = parseInt(parts[0], 10);
                    seconds = parseFloat(parts[1]);
                }

                return (hours * 3600) + (minutes * 60) + seconds;
            };

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                // Skip WEBVTT header or empty lines between
                if (line === "WEBVTT" || line === "") {
                    currentCue = null;
                    continue;
                }

                // Time line: 00:00:00.000 --> 00:00:05.000 (VTT) OR 00:00:00,000 --> ... (SRT)
                if (line.includes('-->')) {
                    const times = line.split('-->');
                    if (times.length === 2) {
                        currentCue = {
                            start: timeToSeconds(times[0].trim()),
                            end: timeToSeconds(times[1].trim()),
                            text: []
                        };
                        cues.push(currentCue);
                    }
                } else if (currentCue) {
                    // Check if this line is an index number (SRT) like "1" before a timestamp
                    // A crude check: if line is numeric and next line is timestamp? 
                    // But we iterate line by line.
                    // If we are INSIDE a cue, we append text.
                    // BUT SRT has numeric headers. 
                    // If line matches integer, we might ignore?
                    // Safe bet: if line is just number, ignore it? 
                    // But maybe "1984" is the text?
                    // Let's assume if it is purely digits, likely an index, BUT context matters.
                    // For now, let's just append. Just numbers will appear in subtitle. Not tragic.

                    // Actually, if we hit a line that looks like timestamp, we start new cue.
                    // But we already handled '-->' above.
                    // So if we are here, it's text.
                    // NOTE: SRT Index lines usually precede timestamps.
                    // If `currentCue` is active, and we see an index line "2", we shouldn't append it to "1".
                    // But "2" line usually comes after an empty line which resets `continue`.
                    // So we are safe mostly.
                    currentCue.text.push(line);
                }
            }

            // Flatten text arrays
            cues.forEach(cue => {
                cue.text = cue.text.join(' ').replace(/<[^>]*>/g, '');
            });

            return cues;
        }

        getTranscript(timestamp) {
            if (!this.cues) return '';
            const context = this.cues.filter(cue =>
                (cue.start >= timestamp - 30) && (cue.end <= timestamp + 30)
            );
            return context.map(c => c.text).join(' ');
        }
    }

    return Subtitle;
});
