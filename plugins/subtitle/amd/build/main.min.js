define(['jquery', 'mod_interactivevideo/type/base', 'core/event_dispatcher'], function ($, BaseModule, EventDispatcher) {

    // Handle ES6 module interoperability
    const Base = (BaseModule && BaseModule.__esModule) ? BaseModule.default : BaseModule;

    /**
     * Main class for the Subtitle plugin
     *
     * @module     ivplugin_subtitle/main
     * @copyright  2024 Antigravity
     * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
     */
    class Subtitle extends Base {

        /**
         * Initialize the subtitle functionality.
         */
        async init() {
            // Find the subtitle annotation(s)
            const subtitleAnnotations = this.annotations.filter(x => x.type === 'subtitle');
            if (!subtitleAnnotations.length) {
                return;
            }

            const annotation = subtitleAnnotations[0];

            // 1. Fetch content
            let htmlContent = '';
            try {
                htmlContent = await this.render(annotation);
            } catch (e) {
                console.error("IV Subtitle: Failed to render content:", e);
                return;
            }

            const $content = $(htmlContent);
            const $container = $content.is('.ivplugin-subtitle-container') ? $content : $content.find('.ivplugin-subtitle-container');

            // Auto-hide the parent interaction wrapper to prevent popups/visual clutter
            // We search for the closest interaction container provided by the parent module
            const $parentWrapper = $container.closest('.iv-interaction, .interaction-card, .card');
            if ($parentWrapper.length) {
                // We use CSS to make it effectively invisible but present
                $parentWrapper.css({
                    'opacity': 0,
                    'width': 0,
                    'height': 0,
                    'margin': 0,
                    'padding': 0,
                    'overflow': 'hidden',
                    'border': 'none',
                    'position': 'absolute',
                    'z-index': -1
                });
            }

            // New logic: Read content from data-subtitle-content (base64)
            const encodedContent = $container.attr('data-subtitle-content');
            const showSubtitle = $container.attr('data-show-subtitle') === '1';

            if (!encodedContent) {
                console.warn("IV Subtitle: No content found.");
                return;
            }

            // 2. Decode and Parse
            try {
                // Decode Base64 (handle utf8)
                const text = decodeURIComponent(escape(atob(encodedContent)));

                // Parse
                this.cues = this.parseVTT(text);
                console.log("IV Subtitle: Parsed cues from embedded content", this.cues.length);

                if (showSubtitle && this.cues.length > 0) {
                    this.updateUI("Subtitles loaded.");
                    setTimeout(() => this.updateUI(""), 2000);
                }

                // Expose globally
                window.IV = window.IV || {};
                window.IV.subtitle = {
                    current: null,
                    all: this.cues,
                    getTranscript: (timestamp) => this.getTranscript(timestamp),
                    getFullTranscript: () => text
                };

                EventDispatcher.dispatchEvent('iv:subtitle:ready', { cues: this.cues });

            } catch (e) {
                console.error("IV Subtitle: Error parsing content:", e);
                return;
            }

            // 3. Setup UI (Only if specifically requested to SHOW)
            // Even if hidden container, we might spawn a floaty if needed?
            // User requested to hide popup. We hidden parent wrapper.
            // If they enabled "Show Subtitle", we should spawn our OWN floating display that isn't inside that hidden wrapper.
            if (showSubtitle) {
                this.ensureOutputContainer();
            }

            // 4. Start Time Loop
            const updateSubtitle = async () => {
                const time = await this.player.getCurrentTime();
                const activeCue = this.cues.find(cue => time >= cue.start && time <= cue.end);

                const currentText = activeCue ? activeCue.text : '';

                if (window.IV.subtitle && window.IV.subtitle.current !== currentText) {
                    window.IV.subtitle.current = currentText;
                    EventDispatcher.dispatchEvent('iv:subtitle:change', { text: currentText, time: time });

                    if (showSubtitle) {
                        this.updateUI(currentText);
                    }
                }
            };

            setInterval(updateSubtitle, 250);
        }

        ensureOutputContainer() {
            // We append to video-wrapper directly, bypassing the hidden interaction card
            if ($('#iv-subtitle-display').length === 0) {
                $('#video-wrapper').append(
                    '<div id="iv-subtitle-display" class="text-center p-2" style="position: absolute; bottom: 10%; width: 100%; pointer-events: none; z-index: 1000; text-shadow: 1px 1px 2px black;"></div>'
                );
            }
            return $('#iv-subtitle-display');
        }

        updateUI(text) {
            const $container = this.ensureOutputContainer();
            if (text) {
                $container.html(`<span class="d-inline-block bg-dark text-white opacity-75 px-3 py-1 rounded" style="font-size: 1.1em; background-color: rgba(0,0,0,0.6) !important;">${text}</span>`);
                $container.show();
            } else {
                $container.hide();
            }
        }

        /**
         * Simple VTT/SRT parser
         */
        parseVTT(vttText) {
            const lines = vttText.trim().split(/\r?\n/);
            const cues = [];
            let currentCue = null;

            const timeToSeconds = (timeStr) => {
                timeStr = timeStr.replace(',', '.');
                const parts = timeStr.split(':');
                let hours = 0, minutes = 0, seconds = 0;

                if (parts.length === 3) {
                    hours = parseInt(parts[0], 10);
                    minutes = parseInt(parts[1], 10);
                    seconds = parseFloat(parts[2]);
                } else if (parts.length === 2) {
                    minutes = parseInt(parts[0], 10);
                    seconds = parseFloat(parts[1]);
                }

                return (hours * 3600) + (minutes * 60) + seconds;
            };

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === "WEBVTT" || line === "") {
                    currentCue = null;
                    continue;
                }

                if (line.includes('-->')) {
                    const times = line.split('-->');
                    if (times.length === 2) {
                        currentCue = {
                            start: timeToSeconds(times[0].trim()),
                            end: timeToSeconds(times[1].trim()),
                            text: []
                        };
                        cues.push(currentCue);
                    }
                } else if (currentCue) {
                    currentCue.text.push(line);
                }
            }

            cues.forEach(cue => {
                cue.text = cue.text.join(' ').replace(/<[^>]*>/g, '');
            });

            return cues;
        }

        getTranscript(timestamp) {
            if (!this.cues) return '';
            const context = this.cues.filter(cue =>
                (cue.start >= timestamp - 30) && (cue.end <= timestamp + 30)
            );
            return context.map(c => c.text).join(' ');
        }
    }

    return Subtitle;
});
