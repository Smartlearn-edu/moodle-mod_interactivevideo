define("ivplugin_aichat/main", ["jquery", "mod_interactivevideo/type/base", "core/str"], function ($, Base, Str) {

    // Helper to handle ES6 module imports interop
    Base = (Base && Base.__esModule) ? Base.default : Base;

    class AIChat extends Base {

        postContentRender(annotation) {
            this.initChatListeners(annotation);
        }

        initChatListeners(annotation) {
            const container = $(`#message[data-id='${annotation.id}']`);
            const sendBtn = container.find('.aichat-send');
            const input = container.find('.aichat-input');
            const messagesArea = container.find('.aichat-messages');
            const self = this; // Capture 'this' for use inside closures

            const sendMessage = async () => {
                const text = input.val().trim();
                if (!text) return;

                // Add User Message
                self.appendMessage(messagesArea, text, 'user');
                input.val('');
                input.prop('disabled', true);
                sendBtn.prop('disabled', true);

                // Add Loading Indicator
                const loadingId = self.appendLoading(messagesArea);

                // Get Context
                const timestamp = await self.player.getCurrentTime();
                const transcript = await self.getTranscriptContext(timestamp);

                // Send to Backend
                $.ajax({
                    url: M.cfg.wwwroot + '/mod/interactivevideo/plugins/aichat/ajax.php',
                    method: "POST",
                    dataType: "json",
                    data: {
                        action: 'chat',
                        contextid: M.cfg.contextid,
                        sesskey: M.cfg.sesskey,
                        itemid: annotation.id,
                        question: text,
                        timestamp: timestamp,
                        transcript: transcript
                    },
                    success: (data) => {
                        self.removeMessage(loadingId);
                        if (data.success) {
                            self.appendMessage(messagesArea, data.response, 'ai');
                        } else {
                            // Using string promise correctly
                            Str.get_string('error_noresponse', 'ivplugin_aichat').then(s => {
                                self.appendMessage(messagesArea, s + (data.error ? ' (' + data.error + ')' : ''), 'ai text-danger');
                            });
                        }
                    },
                    error: () => {
                        self.removeMessage(loadingId);
                        Str.get_string('error_noresponse', 'ivplugin_aichat').then(s => {
                            self.appendMessage(messagesArea, s, 'ai text-danger');
                        });
                    },
                    complete: () => {
                        input.prop('disabled', false);
                        sendBtn.prop('disabled', false);
                        input.focus();
                    }
                });
            };

            sendBtn.off('click').on('click', sendMessage);
            input.off('keypress').on('keypress', (e) => {
                if (e.which === 13) sendMessage();
            });
        }

        async getTranscriptContext(currentTime) {
            return new Promise((resolve) => {
                // Attempt to access text tracks from the HTML5 video element if possible
                // This logic heavily depends on the player implementation (Youtube vs HTML5)

                // For HTML5 video (and some wraps), we might access the underlying video element
                let tracks = [];
                let videoElement = null;

                // Try to find the video element in the player container
                const playerNode = document.getElementById('player'); // Standard ID used in other plugins
                if (playerNode && playerNode.tagName === 'VIDEO') {
                    videoElement = playerNode;
                } else if (playerNode) {
                    videoElement = playerNode.querySelector('video');
                }

                if (videoElement) {
                    // Iterate over text tracks
                    for (let i = 0; i < videoElement.textTracks.length; i++) {
                        let track = videoElement.textTracks[i];
                        if (track.mode === 'showing' || track.mode === 'hidden') { // Use active or hidden tracks
                            if (track.cues) {
                                let contextText = [];
                                // Get cues within +/- 30 seconds
                                for (let j = 0; j < track.cues.length; j++) {
                                    let cue = track.cues[j];
                                    if (cue.endTime >= currentTime - 30 && cue.startTime <= currentTime + 30) {
                                        contextText.push(cue.text);
                                    }
                                }
                                if (contextText.length > 0) {
                                    resolve(contextText.join("\n"));
                                    return;
                                }
                            }
                        }
                    }
                }

                // Fallback
                resolve("");
            });
        }

        appendMessage(container, text, type) {
            const isAi = type === 'ai';
            const icon = isAi ? 'bi-stars text-primary' : 'bi-person-circle text-secondary';
            const bg = isAi ? 'bg-white' : 'bg-primary text-white';
            const align = isAi ? 'align-items-start' : 'align-items-end flex-row-reverse';
            const margin = isAi ? 'me-2' : 'ms-2';

            // Convert simple markdown-like formatting to HTML (basic commonmark)
            if (isAi) {
                // Very simple formatter: bold, code blocks, newlines
                text = text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
                    .replace(/\n/g, '<br>');
            }

            const html = `
            <div class="aichat-message ${type} mb-3 w-100">
                <div class="d-flex ${align}">
                    <i class="bi ${icon} fs-4 ${margin}"></i>
                    <div class="${bg} p-2 px-3 rounded shadow-sm" style="max-width: 85%;">
                        ${text}
                    </div>
                </div>
            </div>`;

            container.append(html);
            this.scrollToBottom(container);
        }

        appendLoading(container) {
            const id = 'loading-' + Date.now();
            // Use Str.get_string promise 
            Str.get_string('thinking', 'ivplugin_aichat').then(thinkingText => {
                const html = `
                <div id="${id}" class="aichat-message ai mb-3 w-100">
                    <div class="d-flex align-items-start">
                        <i class="bi bi-stars text-primary fs-4 me-2"></i>
                        <div class="bg-white p-2 px-3 rounded shadow-sm">
                            <div class="spinner-border spinner-border-sm text-primary" role="status"></div>
                            <span class="ms-2 fs-6 text-muted">${thinkingText}</span>
                        </div>
                    </div>
                </div>`;
                if ($('#' + id).length === 0) { // If not already removed (super fast response)
                    container.append(html);
                    this.scrollToBottom(container);
                }
            });
            return id;
        }

        removeMessage(id) {
            $(`#${id}`).remove();
        }

        scrollToBottom(container) {
            const element = container[0];
            element.scrollTop = element.scrollHeight;
        }

    }

    return AIChat;
});
