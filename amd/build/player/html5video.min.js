define(['jquery', 'core/event_dispatcher', 'mod_interactivevideo/player/checkautoplay'], function ($, EventDispatcher, allowAutoplay) {
    var dispatchEvent = EventDispatcher.dispatchEvent;
    var playerids = {};

    // Check if allowAutoplay is the default export object or the function itself
    // AMD modules from ES6 transpilation sometimes put default in .default
    var checkAutoplay = allowAutoplay;
    if (allowAutoplay && allowAutoplay.default) {
        checkAutoplay = allowAutoplay.default;
    }

    class Html5Video {
        /**
         * Constructor for the HTML5 video player.
         */
        constructor() {
            this.type = "html5video";
            this.frequency = 0.4;
            this.useAnimationFrame = false;
            this.support = {
                playbackrate: true,
                quality: true,
            };
        }
        async getInfo(url, node) {
            this.node = node;
            let self = this;

            const loadVideo = async (player) => {
                // Determine video type based on file extension.
                if (url.indexOf('.m3u8') !== -1) {
                    let Hls = await new Promise(function (resolve, reject) {
                        require(['mod_interactivevideo/player/hls'], function (Mod) { resolve(Mod); }, reject);
                    });
                    // Handle ES6 default export in AMD wrapper if necessary
                    if (Hls && Hls.default) Hls = Hls.default;

                    window.Hls = Hls; // Make Hls globally available.
                    // Handle HLS stream.
                    if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                        var hls = new Hls();
                        this.hls = hls;
                        hls.loadSource(url);
                        // Bind them together.
                        hls.attachMedia(player);
                    } else if (player.canPlayType('application/vnd.apple.mpegurl')) {
                        // Some browsers (like Safari) support HLS natively.
                        player.src = url;
                    }
                } else if (url.indexOf('.mpd') !== -1) {
                    // Handle DASH stream using dash.js.
                    let dashjs = await new Promise(function (resolve, reject) {
                        require(['mod_interactivevideo/player/dash'], function (Mod) { resolve(Mod); }, reject);
                    });
                    if (dashjs && dashjs.default) dashjs = dashjs.default;

                    if (typeof dashjs !== 'undefined') {
                        var dashPlayer = dashjs.MediaPlayer().create();
                        dashPlayer.initialize(player, url, false);
                        this.dash = dashPlayer;
                    }
                } else {
                    // Standard video source.
                    player.src = url;
                }
                return player;
            };
            return new Promise((resolve) => {
                var player = document.getElementById(node);
                playerids[node] = player;
                self.player = player;
                // Play inline.
                player.setAttribute('playsinline', '');

                // Disable picture-in-picture.
                player.setAttribute('disablePictureInPicture', '');
                // eslint-disable-next-line promise/catch-or-return, promise/always-return
                loadVideo(player).then((player) => {
                    player.addEventListener('loadedmetadata', function () {
                        resolve({
                            duration: player.duration,
                            title: player.title,
                            posterImage: player.poster,
                        });
                    });
                });
            });
        }
        /**
         * Loads an instance of an HTML5 video player.
         *
         * @param {string} url - The URL of the video to be played.
         * @param {number} start - The start time of the video in seconds.
         * @param {number} [end] - The end time of the video in seconds. If not provided, defaults to the video's duration.
         * @param {object} opts - The options for the player.
         * @param {boolean} reloaded
         */
        async load(url, start, end, opts = {}, reloaded = false) {
            const showControls = opts.showControls || false;
            const node = opts.node || 'player';
            const autoplay = opts.autoplay || false;
            this.node = node;
            this.start = start;
            this.end = end;
            this.allowAutoplay = await checkAutoplay(document.getElementById(node));
            if (!this.allowAutoplay) {
                dispatchEvent('iv:autoplayBlocked', {
                    requireVideoBlock: true
                });
            }
            var player = document.getElementById(node);
            playerids[node] = player;
            this.posterImage = player.poster;
            // Check if the url is for video or audio.
            const audio = ['mp3', 'wav', 'm4a', 'flac', 'aac', 'wma', 'aiff', 'alac'];
            const ext = url.split('.').pop();
            if (audio.find(e => ext.includes(e))) {
                // Change the player to an audio player.
                this.audio = true;
                // Append a canvas element to the video.
                const canvas = '<canvas id="visualizer"></canvas>';
                player.insertAdjacentHTML('afterend', canvas);
                player.style.visibility = 'hidden';
            }
            // Determine video type based on file extension.
            if (url.indexOf('.m3u8') !== -1) {
                let Hls = await new Promise(function (resolve, reject) {
                    require(['mod_interactivevideo/player/hls'], function (Mod) { resolve(Mod); }, reject);
                });
                if (Hls && Hls.default) Hls = Hls.default;

                window.Hls = Hls; // Make Hls globally available.
                // Handle HLS stream.
                if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                    var hls = new Hls();
                    this.hls = hls;
                    hls.loadSource(url);
                    // Bind them together.
                    hls.attachMedia(player);
                    this.support.quality = true;

                    hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {
                        this.hlsdata = data;
                    });

                    // Handle quality change.
                    hls.on(Hls.Events.LEVEL_SWITCHED, function (event, data) {
                        dispatchEvent('iv:playerQualityChange', { quality: data.level });
                    });

                    hls.on(Hls.Events.ERROR, function (event, data) {
                        if (data.fatal) {
                            dispatchEvent('iv:playerError', { error: data });
                        }
                    });
                } else if (player.canPlayType('application/vnd.apple.mpegurl')) {
                    // Some browsers (like Safari) support HLS natively.
                    player.src = url;
                    this.support.quality = false;
                } else {
                    window.console.error('HLS is not supported in this browser.');
                    this.support.quality = false;
                }
            } else if (url.indexOf('.mpd') !== -1) {
                // Handle DASH stream using dash.js.
                let dashjs = await new Promise(function (resolve, reject) {
                    require(['mod_interactivevideo/player/dash'], function (Mod) { resolve(Mod); }, reject);
                });
                if (dashjs && dashjs.default) dashjs = dashjs.default;

                if (typeof dashjs !== 'undefined') {
                    var dashPlayer = dashjs.MediaPlayer().create();
                    dashPlayer.initialize(player, url, false);
                    this.dash = dashPlayer;
                    dashPlayer.on(dashjs.MediaPlayer.events.REPRESENTATION_SWITCH, function () {
                        const current = dashPlayer.getCurrentRepresentationForType('video');
                        if (!current) {
                            return;
                        }
                        dispatchEvent('iv:playerQualityChange', { quality: current.absoluteIndex });
                    });
                    dashPlayer.on(dashjs.MediaPlayer.events.ERROR, function () {
                        dispatchEvent('iv:playerError');
                    });
                    this.support.quality = true;
                } else {
                    window.console.error('Dash.js library is not loaded.');
                    this.support.quality = false;
                }
            } else {
                // Standard video source.
                player.src = url;
                this.support.quality = false;
            }
            player.controls = showControls;
            player.currentTime = start;
            player.setAttribute('muted', '');

            if (!this.support.quality && document.getElementById('quality')) {
                // Remove quality button if not supported.
                document.getElementById('quality').remove();
            }

            if (document.body.classList.contains('mobiletheme') || autoplay) {
                // Preload video on mobile app. Must mute to avoid browser restriction.
                player.setAttribute('autoplay', '');
            }
            // Disable keyboard controls.
            player.tabIndex = -1;

            let self = this;
            if (!showControls) {
                document.body.classList.add('no-original-controls');
            }

            // Play inline.
            player.setAttribute('playsinline', '');

            // Disable picture-in-picture.
            player.setAttribute('disablePictureInPicture', '');

            player.addEventListener('loadedmetadata', function () {
                self.aspectratio = self.ratio();
                if (isNaN(self.aspectratio)) {
                    self.aspectratio = 16 / 9;
                }
                let totaltime = Number((player.duration).toFixed(2)) - self.frequency;
                if (player.duration === Infinity || isNaN(player.duration) ||
                    (self.hls && self.hls.latencyController.levelDetails.live)) {
                    totaltime = 0.1;
                    self.live = true;
                }
                if (end == 0.1 && !self.live) {
                    end = totaltime;
                }
                end = !end ? totaltime : Math.min(end, totaltime);
                end = Number(end.toFixed(2));
                self.end = end;
                self.totaltime = totaltime;
                self.duration = self.end - self.start;
                player.pause();

                if (self.dash) {
                    self.dash.on(window.dashjs.MediaPlayer.events.STREAM_INITIALIZED, () => {
                        // Turn off the tracks.
                        self.dash.setTextTrack(null);
                        let tracks = self.dash.getTracksFor("text");
                        if (tracks && tracks.length > 0) {
                            tracks = tracks.map(track => {
                                const locale = track.lang.split('-')[0];
                                const country = track.lang.split('-')[1];
                                let displayNames;
                                try {
                                    displayNames = new Intl.DisplayNames([`${M.cfg.language}`], { type: 'language' });
                                } catch (e) {
                                    displayNames = new Intl.DisplayNames(['en'], { type: 'language' });
                                }
                                let label;
                                if (country == 'auto') {
                                    label = displayNames.of(locale) + ' (Auto)';
                                } else {
                                    label = displayNames.of(track.lang) ?? track.lang.toUpperCase();
                                }
                                return {
                                    label,
                                    code: track.lang,
                                };
                            });
                            self.captions = tracks;
                        }
                        dispatchEvent('iv:playerLoaded', {
                            tracks: self.captions || null,
                            reloaded: reloaded,
                        });
                        dispatchEvent('iv:playerReady', null, document.getElementById(node));
                    });
                } else if (self.hls) {
                    // Turn off the tracks.
                    self.hls.subtitleTrack = -1;
                    let tracks = self.hls.subtitleTracks;
                    if (tracks && tracks.length > 0) {
                        tracks = tracks.map(track => {
                            const locale = track.lang.split('-')[0];
                            const country = track.lang.split('-')[1];
                            let displayNames;
                            try {
                                displayNames = new Intl.DisplayNames([`${M.cfg.language}`], { type: 'language' });
                            } catch (e) {
                                displayNames = new Intl.DisplayNames(['en'], { type: 'language' });
                            }
                            let label;
                            if (country == 'auto') {
                                label = displayNames.of(locale) + ' (Auto)';
                            } else {
                                label = displayNames.of(track.lang) ?? track.lang.toUpperCase();
                            }
                            return {
                                label,
                                code: track.lang,
                            };
                        });
                        self.captions = tracks;
                    }
                    dispatchEvent('iv:playerLoaded', {
                        tracks: self.captions || null,
                        reloaded: reloaded,
                    });
                    dispatchEvent('iv:playerReady', null, document.getElementById(node));
                } else { // Standard video source.
                    const tracks = Array.from(player.textTracks).map(t => {
                        let label = t.label;
                        if (!label) {
                            try {
                                const displayNames = new Intl.DisplayNames([`${M.cfg.language}`], { type: 'language' });
                                label = displayNames.of(t.language);
                            } catch (e) {
                                label = t.language.toUpperCase();
                            }
                        }
                        return {
                            label: label,
                            code: t.language
                        };
                    });
                    self.captions = tracks;
                    dispatchEvent('iv:playerLoaded', {
                        tracks: self.captions || null,
                        reloaded: reloaded,
                    });
                    dispatchEvent('iv:playerReady', null, document.getElementById(node));
                }
            });

            player.addEventListener('pause', function () {
                self.paused = true;
                dispatchEvent('iv:playerPaused');
            });

            player.addEventListener('play', function () {
                self.paused = false;
                dispatchEvent('iv:playerPlay');
            });

            player.addEventListener('timeupdate', function () {
                if (self.paused) {
                    return;
                }
                if (player.currentTime < self.start) {
                    player.currentTime = self.start;
                }
                if (player.currentTime >= self.end + self.frequency && !self.live) {
                    player.currentTime = self.end - self.frequency;
                }
                dispatchEvent('iv:playerPlaying');
                if (self.live) {
                    return;
                }
                if (self.ended) {
                    self.ended = false;
                } else {
                    if (!self.ended && player.currentTime >= self.end) {
                        self.ended = true;
                        self.paused = true;
                        player.pause();
                        dispatchEvent('iv:playerEnded');
                    }
                }
            });

            player.addEventListener('error', function (e) {
                dispatchEvent('iv:playerError', { error: e });
            });

            player.addEventListener('ratechange', function () {
                dispatchEvent('iv:playerRateChange', { rate: player.playbackRate });
            });

            player.addEventListener('waiting', function () {
                dispatchEvent('iv:playerBuffering');
            });

            // Volume change event.
            player.addEventListener('volumechange', function () {
                dispatchEvent('iv:playerVolumeChange', { volume: player.volume });
            });

            this.player = player;
        }

        /**
         * Visualizes the audio frequency data of the HTML5 video player using a canvas element.
         */
        visualizer() {
            var context = new AudioContext();
            var src = context.createMediaElementSource(this.player);
            var analyser = context.createAnalyser();
            var canvas = document.getElementById("visualizer");
            if (!canvas) return; // Guard clause

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            var ctx = canvas.getContext("2d");
            src.connect(analyser);
            analyser.connect(context.destination);

            analyser.fftSize = 256;

            var bufferLength = analyser.frequencyBinCount;
            var dataArray = new Uint8Array(bufferLength);

            var WIDTH = canvas.width;
            var HEIGHT = canvas.height;

            var barWidth = (WIDTH / bufferLength) * 2.5;
            var barHeight;
            var x = 0;

            const renderFrame = () => {
                requestAnimationFrame(renderFrame);
                x = 0;
                analyser.getByteFrequencyData(dataArray);
                ctx.fillStyle = "#000";
                ctx.fillRect(0, 0, WIDTH, HEIGHT);

                // Calculate the vertical center
                const centerY = HEIGHT / 2;

                for (var i = 0; i < bufferLength; i++) {
                    barHeight = dataArray[i];
                    var r = barHeight + (25 * (i / bufferLength));
                    var g = 250 * (i / bufferLength);
                    var b = 50;

                    ctx.fillStyle = "rgb(" + r + "," + g + "," + b + ")";
                    // Draw bars centered vertically
                    ctx.fillRect(x, centerY - barHeight / 2, barWidth, barHeight);

                    x += barWidth + 1;
                }
            };
            renderFrame();
        }

        /**
         * plays the HTML5 video using the player instance.
         */
        play() {

            if (!playerids[this.node]) {
                return;
            }
            if (this.live) {
                // Seek to the end of the video to simulate live streaming.
                if (this.dash) {
                    this.dash.seekToOriginalLive();
                }
                if (this.hls) {
                    let seektime = this.hls.liveSyncPosition;
                    this.seek(seektime);
                }
            }
            this.player.play();
            this.paused = false;
        }
        /**
         * Pauses the video playback.
         */
        pause() {
            if (!playerids[this.node]) {
                return false;
            }
            this.player.pause();
            this.paused = true;
            return true;
        }
        /**
         * Stops the video playback and sets the current time to the specified start time.
         */
        stop(starttime) {
            if (!playerids[this.node]) {
                return;
            }
            this.player.pause();
            this.player.currentTime = starttime;
        }
        /**
         * Seeks the video to a specified time.
         */
        seek(time) {
            if (!playerids[this.node]) {
                return time;
            }
            let currentTime = this.getCurrentTime();
            dispatchEvent('iv:playerSeekStart', { time: currentTime });
            this.ended = false;
            this.player.currentTime = time;
            dispatchEvent('iv:playerSeek', { time });
            return true;
        }
        /**
         * Retrieves the current playback time of the video.
         */
        getCurrentTime() {
            if (!playerids[this.node]) {
                return 0;
            }
            return this.player.currentTime;
        }
        /**
         * Retrieves the duration of the video.
         */
        getDuration() {
            if (!playerids[this.node]) {
                return 0;
            }
            return this.player.duration;
        }
        /**
         * Checks if the video player is currently paused.
         */
        isPaused() {
            if (!playerids[this.node]) {
                return true;
            }
            if (this.paused) {
                return true;
            }
            return this.player.paused;
        }
        /**
         * Checks if the video player is currently playing.
         */
        isPlaying() {
            if (!playerids[this.node]) {
                return false;
            }
            if (this.paused) {
                return false;
            }
            return !this.player.paused;
        }

        /**
         * Checks if the video has ended.
         */
        isEnded() {
            if (!playerids[this.node]) {
                return false;
            }
            return this.player.ended || this.player.currentTime >= this.end;
        }
        /**
         * Calculates the aspect ratio of the video.
         */
        ratio() {
            if (!playerids[this.node]) {
                return 16 / 9;
            }
            if (this.audio || !this.player.videoWidth || !this.player.videoHeight) {
                return 16 / 9;
            }
            return this.player.videoWidth / this.player.videoHeight;
        }
        /**
         * Destroys the HTML5 video player instance.
         */
        destroy() {
            $(`#${this.node}`).replaceWith(`<div id="${this.node}" style="width:100%; max-width: 100%"></div>`);
            this.player.pause();
            this.player.removeAttribute('src');
            this.player.load();
            if (this.hls) {
                this.hls.destroy();
            }
            if (this.dash) {
                this.dash.destroy();
            }
            playerids[this.node] = null;
            dispatchEvent('iv:playerDestroyed');
        }
        /**
         * Retrieves the current state of the video player.
         */
        getState() {
            if (!playerids[this.node]) {
                return 'paused';
            }
            return this.player.paused ? 'paused' : 'playing';
        }

        /**
         * Sets the playback rate of the video player.
         */
        setRate(rate) {
            if (!playerids[this.node]) {
                return;
            }
            this.player.playbackRate = rate;
        }

        /**
         * Mutes the HTML5 video player.
         */
        mute() {
            if (!playerids[this.node]) {
                return;
            }
            this.player.muted = true;
            this.player.volume = 0;
            dispatchEvent('iv:playerVolumeChange', { volume: 0 });
        }
        /**
         * Unmutes the video player.
         */
        unMute() {
            if (!playerids[this.node]) {
                return;
            }
            this.player.muted = false;
            this.player.volume = 1;
            dispatchEvent('iv:playerVolumeChange', { volume: 1 });
        }

        isMuted() {
            if (!playerids[this.node]) {
                return false;
            }
            return this.player.muted;
        }

        /**
         * Returns the original video player instance.
         */
        originalPlayer() {
            if (!playerids[this.node]) {
                return null;
            }
            return this.player;
        }

        /**
         * Sets the video quality.
         */
        setQuality(quality) {
            if (!playerids[this.node]) {
                return quality;
            }
            if (this.support.quality) {
                // Implement quality change here.
                if (this.hls) {
                    this.hls.currentLevel = quality;
                } else if (this.dash) {
                    if (quality === -1) {
                        // Enable automatic quality switching.
                        this.dash.updateSettings({
                            streaming: {
                                abr: {
                                    autoSwitchBitrate: {
                                        video: true
                                    }
                                }
                            }
                        });
                    } else {
                        // Disable automatic quality switching and set manual quality.
                        this.dash.updateSettings({
                            streaming: {
                                abr: {
                                    autoSwitchBitrate: {
                                        video: false
                                    }
                                }
                            }
                        });
                        this.dash.setRepresentationForTypeByIndex('video', quality);
                    }
                }
            }
            return quality;
        }

        getQualities() {
            if (!playerids[this.node]) {
                return null;
            }
            if (this.support.quality) {
                // Prepend an "Auto" option for quality selection.
                let keys, values, current;
                if (this.hls) {
                    keys = [-1, ...this.hls.levels.map((level, index) => index)];
                    values = ['Auto', ...this.hls.levels.map((level) => level.height + 'p')];
                    current = this.hls.currentLevel;
                } else if (this.dash) {
                    const qualities = this.dash.getRepresentationsByType('video');
                    keys = [-1, ...qualities.map((quality) => quality.absoluteIndex)];
                    values = ['Auto', ...qualities.map((quality) => quality.height
                        + 'p (' + Math.round(quality.bitrateInKbit) + 'kbps)')];
                    current = this.dash.getCurrentRepresentationForType('video').absoluteIndex;
                    if (!current) {
                        current = -1;
                    }
                }

                return {
                    qualities: keys,
                    qualitiesLabel: values,
                    currentQuality: current,
                };
            }
            return [];
        }

        /**
         * Sets the caption track for the video player.
         * @param {string} track - The caption track to set.
         */
        setCaption(track) {
            if (!playerids[this.node]) {
                return null;
            }
            if (this.dash) {
                if (track === 'off' || track == '') {
                    this.dash.setTextTrack(null);
                } else {
                    const tracks = this.dash.getTracksFor('text');
                    if (tracks && tracks.length > 0) {
                        const selectedTrack = tracks.find(t => t.lang === track);
                        if (selectedTrack) {
                            this.dash.setTextTrack(selectedTrack.id);
                        } else {
                            window.console.warn('Caption track not found:', track);
                        }
                    }
                }
            } else if (this.hls) {
                if (track === 'off' || track == '') {
                    this.hls.subtitleTrack = -1; // Disable subtitles.
                } else {
                    const tracks = this.hls.subtitleTracks;
                    if (tracks && tracks.length > 0) {
                        const selectedTrack = tracks.find(t => t.lang === track);
                        if (selectedTrack) {
                            this.hls.subtitleTrack = selectedTrack.id;
                        } else {
                            window.console.warn('Caption track not found:', track);
                        }
                    }
                }
            } else {
                // Standard HTML5 video.
                const tracks = Array.from(this.player.textTracks);
                tracks.forEach(t => {
                    if (track === 'off' || track === '') {
                        t.mode = 'hidden';
                    } else if (t.language === track) {
                        t.mode = 'showing';
                    } else {
                        t.mode = 'hidden';
                    }
                });
            }
            return track;
        }
    }

    return Html5Video;
});